# 동형암호 기반 사인 함수 근사 (Taylor Series, OpenFHE)

이 프로젝트는 OpenFHE의 BGV 스킴을 이용해, 입력값을 정수 스케일링 후 암호화하고 암호공간에서 테일러 다항식으로 sin(x)를 근사하는 실험 코드입니다.

---

## 주요 특징 및 구현 방식

- **입력 생성**: -180도 ~ 180도 범위에서 10도 간격으로 테스트
- **정수 스케일링**: x_scaled = round(s * x)
- **테일러 계수 정수화**: c1, c3 (3차) 또는 c1, c3, c5 (5차)를 s, denom 곱해서 정수화
- **암호화/암호공간 연산**:
    - x_scaled만 암호화
    - 암호공간에서 다항식 연산 수행
    - 모든 다항식 연산은 암호공간에서만 수행
- **복호화 및 역스케일링**: y_recovered = y_scaled / (denom * s^n)
- **실제값, 근사값, 오차 및 성능 측정**

---

## 워크스페이스 최초 사용법 (깃 클론)

```bash
git clone <이 저장소 주소>
cd <저장소 디렉토리>
```

---

## 빌드 및 실행 방법

### 자동 빌드/실행 (추천)

```bash
bash build.sh
```
- 자동으로 build 디렉토리에서 cmake/make 후, 빌드 성공 시 실행파일들을 바로 실행합니다.

### 수동 빌드/실행

```bash
mkdir -p build
cd build
cmake ..
make
./sin_taylor_third    # 3차 근사
./sin_taylor_fifth    # 5차 근사
```

---

## 실험 결과 비교

### 3차 근사 (sin(x) ≈ x - x³/6)

#### 파라미터
- **스케일링 상수(s)**: 50
- **정수화 분모(denom)**: 6
- **플레인텍스트 모듈러스**: 7340033 (약 22.8비트, NTT-friendly 소수)
- **곱셈 뎁스**: 3 (3차 근사에 충분)
- **링 차원**: 16384 (128비트 보안을 위해)
- **보안 레벨**: HEStd_128_classic

#### 성능 측정 결과
- **평균 암호화 시간**: ~8.7ms
- **평균 연산 시간**: ~29.8ms  
- **평균 복호화 시간**: ~3.5ms
- **평균 총 소요 시간**: ~42.1ms

#### 정확도 분석
- **최대 오차**: 0.077 (90도에서)
- **평균 오차**: ~0.01
- **-30도 ~ 30도 범위**: 오차 < 0.01 (매우 정확)
- **±60도 이상**: 오차 증가 (테일러 급수의 한계)

### 3차 근사 분석

**파라미터:**
- PlaintextModulus: 7340033 (약 22.8비트)
- PlaintextModulus/2: 3670016
- ic1: 15000, ic3: -1

**실제 값 비교 (180도 예시):**
- term1_raw: 2355000 (약 32.1% of PlaintextModulus)
- term2_raw: 3470140 (약 47.3% of PlaintextModulus)
- **결론**: 3차 근사는 모듈러스의 50% 이내로 안전한 범위

---

### 5차 근사 (sin(x) ≈ x - x³/6 + x⁵/120)

#### 파라미터
- **스케일링 상수(s)**: 50
- **정수화 분모(denom)**: 120
- **플레인텍스트 모듈러스**: 1099512004609 (약 40비트)
- **곱셈 뎁스**: 6
- **링 차원**: 8192 (모듈러스 크기 제한으로 인해 축소)
- **보안 레벨**: HEStd_NotSet

#### 성능 측정 결과
- **평균 암호화 시간**: ~6.0ms
- **평균 연산 시간**: ~30.5ms  
- **평균 복호화 시간**: ~4.5ms
- **평균 총 소요 시간**: ~41.0ms

#### 정확도 분석
- **최대 오차**: 0.523 (180도에서)
- **평균 오차**: ~0.05
- **-90도 ~ 90도 범위**: 오차 < 0.02 (매우 정확)
- **±120도 이상**: 오차 증가하지만 3차보다 개선

### 5차 근사 분석

**파라미터:**
- PlaintextModulus: 1099512004609 (약 40비트)
- PlaintextModulus/2: 549756002304
- ic1: 750000000, ic3: -50000, ic5: 1

**실제 값 비교 (180도 예시):**
- term1_raw: 117750000000 (약 10.7% of PlaintextModulus)
- term2_raw: -193494650000 (약 -17.6% of PlaintextModulus)
- term3_raw: 95388992557 (약 8.7% of PlaintextModulus)
- **결론**: 5차 근사는 모듈러스의 18%까지 사용하여 더 큰 값 처리

---

## 성능 및 정확도 비교

| 항목 | 3차 근사 | 5차 근사 |
|------|----------|----------|
| **총 소요 시간** | ~42.1ms | ~41.0ms |
| **연산 시간 비중** | ~70% | ~74% |
| **최대 오차** | 0.077 | 0.523 |
| **정확한 범위** | ±30도 | ±90도 |
| **보안 레벨** | 128비트 | NotSet |
| **링 차원** | 16384 | 8192 |
| **메모리 사용량** | 높음 | 낮음 |

---

## 링 차원과 모듈러스 크기의 관계

### 왜 링 차원을 줄여야 하는가?

1. **링 차원이 클수록** → 더 많은 모듈러스가 필요
2. **곱셈 뎁스가 클수록** → 더 큰 모듈러스가 필요  
3. **5차 근사 (6 뎁스) + 16384 링 차원** → 60비트 제한 초과

### 구체적인 이유:
- **다항식 차수**: 링 차원이 클수록 다항식의 최대 차수가 높아져서 더 큰 수를 표현해야 함
- **노이즈 누적**: 곱셈 연산 시 노이즈가 누적되므로, 이를 흡수할 수 있는 충분히 큰 모듈러스가 필요
- **보안 요구사항**: 높은 보안 레벨은 더 큰 모듈러스를 요구하지만, NotSet을 사용해도 5차 근사의 복잡성으로 인해 모듈러스 크기 제한에 걸림

### 해결책:
- **링 차원 축소**: 16384 → 8192로 줄여서 모듈러스 크기 감소
- **성능 영향**: 링 차원이 작아져도 5차 근사의 정확도는 유지
- **메모리 효율성**: 더 작은 링 차원으로 메모리 사용량 감소

---

## 스케일 다운 전 값과 모듈러스 크기 비교

### 비교 분석

| 항목 | 3차 근사 | 5차 근사 |
|------|----------|----------|
| **최대 term 크기** | ~3.5M (47.3%) | ~193M (17.6%) |
| **모듈러스 사용률** | 중간 | 낮음 |
| **안전 마진** | 충분함 | 매우 높음 |
| **스케일링 효율성** | 중간 | 높음 |

**핵심 발견사항:**
1. **3차 근사**: 모듈러스의 50% 이내로 안전한 범위
2. **5차 근사**: 모듈러스의 18%까지 사용하지만 여전히 안전
3. **링 차원 영향**: 5차 근사에서 더 큰 값들이 생성되지만 모듈러스 크기 제한 내에서 처리 가능
4. **실제 사용률**: 3차 근사가 예상보다 높은 모듈러스 사용률을 보임 (47.3%)

---

## 출력 예시

### 3차 근사 결과
```
각도(도)    x_input(rad)    근사값    실제값    오차    term1_raw    term2_raw    term1_mod    term2_mod    암호화(ms)    연산(ms)    복호화(ms)    총시간(ms)
-90         -1.570796       -0.922615 -1.000000 0.077385    -1185000     493039      -1185000     493039      10.02       30.33       3.23        43.58
0           0.000000        0.000000  0.000000  0.000000    0           0           0           0           8.24        29.78       3.47        41.49
90          1.570796        0.922615  1.000000  0.077385    1185000     -493039     1185000     -493039     8.15        30.41       3.19        41.75
```

### 5차 근사 결과
```
각도(도)    x_input(rad)    근사값    실제값    오차    term1_raw        term2_raw        term3_raw    term1_mod       term2_mod        term3_mod       암호화(ms)    연산(ms)    복호화(ms)    총시간(ms)
-90         -1.570796       -1.000000 -1.000000 0.000000    -59250000000    24651950000     -3077056399    -59250000000    24651950000     -3077056399    5.03        27.08       4.25        36.36
0           0.000000        0.000000  0.000000  0.000000    0             0             0             0             0             0             5.76        29.59       4.37        39.72
90          1.570796        1.000000  1.000000  0.000000    59250000000    -24651950000    3077056399    59250000000    -24651950000    3077056399     5.79        34.19       4.38        44.36
180         3.141593        -0.523849 0.000000  0.523849    -117750000000 193494650000    -95388992557  -117750000000 193494650000    -95388992557  6.72        32.15       4.55        43.42
```

---

## 제한사항 및 주의사항

- **플레인텍스트 모듈러스 제한**: OpenFHE에서 60비트 이하로 제한
- **테일러 급수의 한계**: 각도가 커질수록 오차 증가
- **성능 특성**: 연산 시간이 가장 오래 걸림 (전체의 ~70-75%)
- **메모리 요구사항**: 링 차원에 따른 메모리 사용량 변화
- **보안 레벨 트레이드오프**: 5차 근사는 NotSet 사용으로 성능 향상
- **링 차원-모듈러스 트레이드오프**: 높은 차수 근사는 링 차원 축소 필요
- OpenFHE 라이브러리 및 의존성 설치 필요

---

## 최적화 방향

1. **파라미터 조정**: 스케일링 상수, 링 차원 조정으로 성능/정확도 트레이드오프
2. **다항식 차수**: 7차 이상으로 확장하여 정확도 향상 가능
3. **압축 기법**: 암호문 압축으로 메모리 사용량 감소
4. **병렬화**: 여러 입력값에 대한 병렬 처리
5. **보안 레벨 최적화**: 정확도와 성능의 균형점 찾기
6. **링 차원 최적화**: 모듈러스 크기 제한 내에서 최적의 링 차원 선택

---

## 참고
- **3차 근사**: sin(x) ≈ x - x³/6 (빠르지만 정확도 제한)
- **5차 근사**: sin(x) ≈ x - x³/6 + x⁵/120 (정확하지만 복잡)
- 모든 다항식 연산은 암호공간에서만 수행
- 실험 목적: 동형암호 환경에서의 다항식 근사, 오차 및 성능 특성 분석 